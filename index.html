<!DOCTYPE html>
<html>
  <head>
    <title>Projet Data Viz : Données Spotify</title>
    <meta charset="utf-8" />
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script>
      function Pack(
        data,
        {
          // data is either tabular (array of objects) or hierarchy (nested objects)
          path, // as an alternative to id and parentId, returns an array identifier, imputing internal nodes
          id = Array.isArray(data) ? (d) => d.id : null, // if tabular data, given a d in data, returns a unique identifier (string)
          parentId = Array.isArray(data) ? (d) => d.parentId : null, // if tabular data, given a node d, returns its parent’s identifier
          children, // if hierarchical data, given a d in data, returns its children
          value, // given a node d, returns a quantitative value (for area encoding; null for count)
          sort = (a, b) => d3.descending(a.value, b.value), // how to sort nodes prior to layout
          label, // given a leaf node d, returns the display name
          title, // given a node d, returns its hover text
          link, // given a node d, its link (if any)
          linkTarget = "_blank", // the target attribute for links, if any
          width = 640, // outer width, in pixels
          height = 400, // outer height, in pixels
          margin = 1, // shorthand for margins
          marginTop = margin, // top margin, in pixels
          marginRight = margin, // right margin, in pixels
          marginBottom = margin, // bottom margin, in pixels
          marginLeft = margin, // left margin, in pixels
          padding = 3, // separation between circles
          fill = "#ddd", // fill for leaf circles
          fillOpacity, // fill opacity for leaf circles
          stroke = "#bbb", // stroke for internal circles
          strokeWidth, // stroke width for internal circles
          strokeOpacity // stroke opacity for internal circles
        } = {}
      ) {
        // If id and parentId options are specified, or the path option, use d3.stratify
        // to convert tabular data to a hierarchy; otherwise we assume that the data is
        // specified as an object {children} with nested objects (a.k.a. the “flare.json”
        // format), and use d3.hierarchy.
        const root =
          path != null
            ? d3.stratify().path(path)(data)
            : id != null || parentId != null
            ? d3.stratify().id(id).parentId(parentId)(data)
            : d3.hierarchy(data, children);

        // Compute the values of internal nodes by aggregating from the leaves.
        value == null ? root.count() : root.sum((d) => Math.max(0, value(d)));

        // Compute labels and titles.
        const descendants = root.descendants();
        const leaves = descendants.filter((d) => !d.children);
        leaves.forEach((d, i) => (d.index = i));
        const L = label == null ? null : leaves.map((d) => label(d.data, d));
        const T =
          title == null ? null : descendants.map((d) => title(d.data, d));

        // Sort the leaves (typically by descending value for a pleasing layout).
        if (sort != null) root.sort(sort);

        // Compute the layout.
        d3
          .pack()
          .size([
            width - marginLeft - marginRight,
            height - marginTop - marginBottom
          ])
          .padding(padding)(root);

        const svg = d3
          .create("svg")
          .attr("viewBox", [-marginLeft, -marginTop, width, height])
          .attr("width", width)
          .attr("height", height)
          .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
          .attr("font-family", "sans-serif")
          .attr("font-size", 10)
          .attr("text-anchor", "middle");

        const node = svg
          .selectAll("a")
          .data(descendants)
          .join("a")
          .attr("xlink:href", link == null ? null : (d, i) => link(d.data, d))
          .attr("target", link == null ? null : linkTarget)
          .attr("transform", (d) => `translate(${d.x},${d.y})`);

        node
          .append("circle")
          .attr("fill", (d) => (d.children ? "#fff" : fill))
          .attr("fill-opacity", (d) => (d.children ? null : fillOpacity))
          .attr("stroke", (d) => (d.children ? stroke : null))
          .attr("stroke-width", (d) => (d.children ? strokeWidth : null))
          .attr("stroke-opacity", (d) => (d.children ? strokeOpacity : null))
          .attr("r", (d) => d.r);

        if (T) node.append("title").text((d, i) => T[i]);

        if (L) {
          // A unique identifier for clip paths (to avoid conflicts).
          const uid = `O-${Math.random().toString(16).slice(2)}`;

          const leaf = node.filter(
            (d) => !d.children && d.r > 10 && L[d.index] != null
          );

          leaf
            .append("clipPath")
            .attr("id", (d) => `${uid}-clip-${d.index}`)
            .append("circle")
            .attr("r", (d) => d.r);

          leaf
            .append("text")
            .attr(
              "clip-path",
              (d) => `url(${new URL(`#${uid}-clip-${d.index}`, location)})`
            )
            .selectAll("tspan")
            .data((d) => `${L[d.index]}`.split(/\n/g))
            .join("tspan")
            .attr("x", 0)
            .attr("y", (d, i, D) => `${i - D.length / 2 + 0.85}em`)
            .attr("fill-opacity", (d, i, D) =>
              i === D.length - 1 ? 0.7 : null
            )
            .text((d) => d);
        }

        return svg.node();
      }

      function onlyUnique(value, index, self) {
        return self.indexOf(value) === index;
      }

      function onlyUniqueDate(value, index, self) {
        return self.indexOf(value) === index;
      }

      function setup_visu1(json) {
        var tab = {};
        for (var i in json) {
          if (json[i].artistName in tab) {
            tab[json[i].artistName] += json[i].msPlayed;
          } else {
            tab[json[i].artistName] = json[i].msPlayed;
          }
        }

        var tab2 = [];
        for (var i in tab) {
          tab2.push({ name: i, msPlayed: tab[i] });
        }
        var obj = { name: "visu", children: tab2 };
        var visu = Pack(obj, {
          value: (d) => d.msPlayed,
          label: (d, n) => d.name,
          width: 1200,
          height: 1200
        });
        var element = document.getElementById("visu1");
        element.appendChild(visu);
      }

      function setup_visu2(json) {
        var tab = {};
        for (var i in json) {
          if (json[i].artistName in tab) {
            var tr = tab[json[i].artistName].find((d) => {
              return json[i].trackName === d.track;
            });
            if (tr === undefined) {
              tab[json[i].artistName].push({
                track: json[i].trackName,
                msPlayed: json[i].msPlayed
              });
            } else {
              tr.msPlayed += json[i].msPlayed;
            }
          } else {
            tab[json[i].artistName] = [
              { track: json[i].trackName, msPlayed: json[i].msPlayed }
            ];
          }
        }
        var tab2 = [];
        for (var i in tab) {
          tab2.push({ name: i, children: tab[i] });
        }
        var obj = { name: "visu", children: tab2 };
        var visu = Pack(obj, {
          value: (d) => d.msPlayed,
          label: (d, n) => {
            return d.track;
          },
          width: 1200,
          height: 1200
        });
        var element = document.getElementById("visu2");
        element.appendChild(visu);
      }

      function setup_visu3(json) {
        var margin = { top: 10, right: 30, bottom: 40, left: 70 },
          width = 1400 - margin.left - margin.right,
          height = 1200 - margin.top - margin.bottom;

        const svg = d3
          .select("#visu3")
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        var pp = true;
        json.forEach((d) => {
          d.msPlayed = Math.round(d.msPlayed / 1000);
        });

        var dates = [];
        var artistes = [];
        var tab_ms_by_day = {};
        for (var i in json) {
          var tt = new Date(json[i].endTime);
          var tt2 = new Date(tt.getFullYear(), tt.getMonth(), tt.getDate());
          json[i].endTime = tt2;
          dates.push(tt2);
          artistes.push(json[i].artistName);

          if (json[i].endTime in tab_ms_by_day) {
            tab_ms_by_day[json[i].endTime] += json[i].msPlayed;
          } else {
            tab_ms_by_day[json[i].endTime] = json[i].msPlayed;
          }
        }

        dates = dates.filter(
          (date, i, self) =>
            self.findIndex((d) => d.getTime() == date.getTime()) === i
        );
        artistes = artistes.filter(onlyUnique);

        var map1 = new Map();

        var data = [];

        dates.forEach((d) => {
          var data_date = json.filter((j) => {
            return j.endTime.getTime() == d.getTime();
          });
          var dico = {};
          dico["date"] = d;

          var tab = [];
          artistes.forEach((a) => {
            var art_obt = data_date.filter((jse) => {
              return jse.artistName === a;
            });
            if (art_obt.length != 0) {
              var somme = 0;
              art_obt.forEach((s) => {
                somme += s.msPlayed;
              });
              tab.push(somme);
            } else {
              tab.push(0);
            }
          });

          for (var i in artistes) {
            dico[artistes[i]] = tab[i];
          }
          data.push(dico);
          map1.set(d, tab);
        });

        var min_date = d3.min(dates, function (d) {
          return d;
        });

        var max_date = d3.max(dates, function (d) {
          return d;
        });

        var max_ms = d3.max(Object.values(tab_ms_by_day), function (d) {
          return d;
        });

        const x = d3.scaleUtc().domain([min_date, max_date]).range([0, width]);

        const x_axis = d3
          .axisBottom(x)
          .tickValues(dates)
          .tickFormat(d3.timeFormat("%d-%m"));

        svg
          .append("g")
          .attr("transform", "translate(0," + height + ")")
          .call(x_axis)
          .selectAll("text")
          .style("text-anchor", "end")
          .attr("dx", "-.8em")
          .attr("dy", ".15em")
          .attr("transform", function (d) {
            return "rotate(-30)";
          });

        const y = d3.scaleLinear().domain([0, max_ms]).range([height, 0]);
        svg.append("g").call(d3.axisLeft(y));

        const color = d3
          .scaleSequential()
          .domain([0, artistes.length - 1])
          .interpolator(d3.interpolateSinebow);

        var stackedData = d3.stack().keys(artistes)(data);

        const jour_en_ms = 86400000;

        const nb_jours = Math.round(
          (max_date.getTime() - min_date.getTime()) / jour_en_ms
        );

        const bandwidth = width / nb_jours;

        const tooltip = d3
          .select("#visu3")
          .append("div")
          .style("position", "absolute")
          .style("visibility", "hidden")
          .attr("class", "tooltip")
          .style("background-color", "white")
          .style("border", "solid")
          .style("border-width", "1px")
          .style("border-radius", "5px")
          .style("padding", "10px");

        const mouseover = function (event, d) {
          const artiste_name = d3.select(this.parentNode).datum().key;
          const ms_played = d.data[artiste_name];
          tooltip
            .html(
              "Artiste: " +
                artiste_name +
                "<br>" +
                "secondes écoutées: " +
                ms_played
            )
            .style("visibility", "visible");
        };
        const mousemove = function (e, d) {
          var mousePosition = [e.x, e.y];
          tooltip
            .style("transform", "translateY(-55%)")
            .style("left", e.x + "px")
            .style("top", e.y - 30 + "px");
        };
        const mouseleave = function (event, d) {
          tooltip.style("visibility", "hidden");
        };

        svg
          .append("g")
          .selectAll("g")
          .data(stackedData)
          .join("g")
          .attr("fill", (d) => color(artistes.indexOf(d.key)))
          .selectAll("rect")
          .data((d) => d)
          .join("rect")
          .attr("x", (d) => x(d.data.date))
          .attr("y", (d) => y(d[1]))
          .attr("height", (d) => y(d[0]) - y(d[1]))
          .attr("width", bandwidth)
          .attr("stroke", "grey")
          .on("mouseover", mouseover)
          .on("mousemove", mousemove)
          .on("mouseleave", mouseleave);
      }

      var tab_visus = ["visu1", "visu2", "visu3"];

      const map_id_visus = new Map();

      map_id_visus.set("1", ["visu1"]);
      map_id_visus.set("2", ["visu2"]);
      map_id_visus.set("3", ["visu3"]);

      function affichage(d) {
        var x = document.getElementById("visu-select");
        map_id_visus.forEach((k, v) => {
          k.forEach((s) => {
            if (v === x.value) {
              $("#" + s).show();
            } else {
              $("#" + k).hide();
            }
          });
        });
      }
    </script>
    <style>
      body {
        margin: 0;
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
      }
    </style>
  </head>

  <body>
    <select name="select-circle" id="visu-select">
      <option value="1">Artists</option>
      <option value="2">Tracks</option>
      <option value="3">Ecoutes par jour</option>
    </select>
    <script>
      document
        .getElementById("visu-select")
        .addEventListener("change", (d) => affichage(d));
    </script>
    <div id="visu1"></div>
    <div id="visu2" style="display: none;"></div>
    <div id="visu3" style="display: none;"></div>
    <script>
      d3.json("StreamingHistory0.json").then((json) => {
        setup_visu1(json);
        setup_visu2(json);
        setup_visu3(json);
      });

      /*Promise.all([d3.json("StreamingHistory0.json"), d3.json("artists.json")])
            					.then(function (files) {
            					})
            					.catch(function (err) {
            					});*/
    </script>
  </body>
</html>
